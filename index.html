    <script>
        // API Key integrated as requested
        const apiKey = "Gen-lang-client-0754154495"; 
        const model = "gemini-2.5-flash-preview-09-2025";
        
        let selections = {
            niche: 'Explainer Video',
            style: 'Minimalist',
            character: 'Male Lead',
            consistency: 'Persistent'
        };

        function selectOption(type, value) {
            selections[type] = value;
            const gridMap = { niche: 'nicheGrid', style: 'styleGrid', character: 'characterGrid', consistency: 'consistencyGrid' };
            const container = document.getElementById(gridMap[type]);
            if (container) {
                container.querySelectorAll('button').forEach(btn => btn.classList.toggle('active', btn.dataset.value === value));
            }
        }

        function showMessage(msg, isError = false) {
            const box = document.getElementById('messageBox');
            box.textContent = msg;
            box.className = `block mb-6 p-4 rounded-xl text-center font-bold text-[10px] tracking-widest ${isError ? 'bg-red-500/10 text-red-500 border border-red-500/30' : 'bg-blue-500/10 text-blue-500 border border-blue-500/30'}`;
            setTimeout(() => box.classList.add('hidden'), 5000);
        }

        async function fetchWithRetry(url, payload, maxRetries = 5) {
            let delay = 1000;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    });
                    
                    if (response.ok) {
                        return await response.json();
                    }
                    
                    if (response.status >= 400 && response.status < 500) {
                        const errData = await response.json().catch(() => ({}));
                        throw new Error(errData.error?.message || `Request failed with status ${response.status}`);
                    }
                } catch (e) {
                    if (i === maxRetries - 1) throw e;
                }
                await new Promise(r => setTimeout(r, delay));
                delay *= 2;
            }
        }

        async function handleGenerate() {
            const topic = document.getElementById('topic').value.trim();
            if (!topic) { showMessage("Concept topic required", true); return; }

            const btn = document.getElementById('generateBtn');
            const btnLoader = document.getElementById('btnLoader');
            const outputContainer = document.getElementById('outputContainer');
            const emptyState = document.getElementById('emptyState');

            btn.disabled = true;
            btnLoader.classList.remove('hidden');

            const tone = document.getElementById('toneSelect').value;
            const platform = document.getElementById('platformSelect').value;

            const systemPrompt = `You are a Pro Video Editor & Storyboard Artist.
            PRODUCTION SPECS:
            - Niche: ${selections.niche} | Style: ${selections.style}
            - Subject: ${selections.character} | Consistency: ${selections.consistency}
            - Platform: ${platform} | Tone: ${tone}

            STRICT INSTRUCTIONS:
            1. SHOT-BY-SHOT STORYTELLING: Generate a sequential, chronological narrative sequence of shots that tell a visual story.
            2. VISUAL CONTINUITY: If Persistent, define a 'Physical Identity Profile' and embed it in every prompt featuring that character.
            3. TECHNICAL PRECISION: Define specific Shot Sizes, Camera Movements, and Lighting.
            
            OUTPUT FORMATTING:
            - Use clear headers for [Title], [Narration], and [Storyboard].
            - MUST use marker "### SCRIPT_ONLY_START" before raw script.
            - MUST use marker "### BATCH_PROMPTS_START" before raw sequential prompts.`;

            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: `Create a professional sequential shot-by-shot production build for: "${topic}"` }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] }
            };

            try {
                const data = await fetchWithRetry(url, payload);
                
                const resultText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!resultText) throw new Error("Build response was empty.");
                
                const parts = resultText.split("### SCRIPT_ONLY_START");
                const mainContent = parts[0];
                const rest = parts[1] || "";
                const [scriptPart, promptsPart] = rest.split("### BATCH_PROMPTS_START");

                document.getElementById('mainOutput').innerHTML = mainContent
                    .replace(/^## (.*$)/gim, '<h2 class="text-xl font-bold mt-8 mb-4 text-blue-500">$1</h2>')
                    .replace(/\*\*(.*)\*\*/g, '<strong class="text-white">$1</strong>')
                    .replace(/\n/g, '<br>');
                    
                document.getElementById('batchNarration').innerText = (scriptPart || "").trim();
                
                const cleanPrompts = (promptsPart || "").trim()
                    .split('\n')
                    .filter(l => l.trim().length > 20)
                    .map(l => l.replace(/^\d+\.\s*/, '').replace(/^-\s*/, '').trim())
                    .join('\n\n');
                    
                document.getElementById('batchOutput').innerText = cleanPrompts;

                emptyState.classList.add('hidden');
                outputContainer.classList.remove('hidden');
                showMessage("Workflow Build Complete");
            } catch (e) {
                console.error(e);
                showMessage(e.message, true);
            } finally {
                btn.disabled = false;
                btnLoader.classList.add('hidden');
            }
        }

        function copyToClipboard(id, msg) {
            const el = document.getElementById(id);
            const textarea = document.createElement('textarea');
            textarea.value = el.innerText;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            showMessage(msg);
        }
    </script>
    